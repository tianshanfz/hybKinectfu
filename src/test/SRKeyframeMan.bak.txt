/*
 * SRKeyframeMan.cpp
 *
 *  Created on: Jun 27, 2016
 *      Author: hanyinbo
 */

#include "SRKeyframeMan.h"
#include"../cuda/DepthCamera.h"
#include "../cuda/CudaDeviceDataMan.h"
#include "../cuda/CudaWrappers.h"
#include "BlurEstimation.h"
void SRKeyframeMan::updateFrame(const DepthFrameData& frame_depth,const ColorFrameData& frame_color,
								const Mat44& camera_pose,const CameraParams& depth_camera_params)
{
	if(_cur_bundle_size==0)
	{//add new keyframe
		calNewSRFrame(frame_depth,frame_color,camera_pose);
	}
	else
	{
		fusionToSRFrame(frame_depth,camera_pose,depth_camera_params);
	}
	_cur_bundle_size=(_cur_bundle_size+1)%_frame_bundle_size;
}
void SRKeyframeMan::showSRFrame()
{
	_srframe_list.back().frame_depth.showFrame("sr frame");
	copySRFrameToGPU();
	cudaCalculateNewVertices(AppParams::instance()->_depth_camera_params);
	cudaCalculateNewNormals();
}
void SRKeyframeMan::copySRFrameToGPU()
{
	cv::Mat mat_depth=_srframe_list.back().frame_depth.mat();
	DepthfMap2D depth_data_cpu;
	int rows=mat_depth.rows,cols=mat_depth.cols;
	depth_data_cpu.create_cpu(cols,rows);
	depth_data_cpu.setZero();
	for(int row=0;row<rows;row++)
	{
		for(int col=0;col<cols;col++)
		{
			float v=mat_depth.at<unsigned short>(row,col)*0.001;//millimeter to meters
			depth_data_cpu.set_data(col,row,v);
		}
	}
	CudaDeviceDataMan::instance()->_raw_depth.copyFrom(depth_data_cpu);
	cudaTruncDepth(AppParams::instance()->_depth_prepocess_params.fMinTrunc,AppParams::instance()->_depth_prepocess_params.fMaxTrunc);
	cudaBiliearFilterDepth(AppParams::instance()->_depth_prepocess_params.fSigmaPixel,AppParams::instance()->_depth_prepocess_params.fSigmaDepth);
	depth_data_cpu.destroy();

}
void SRKeyframeMan::updateDepthBranch(const DepthFrameData& frame_depth,const Mat44& camera_pose)
{
	cv::Mat new_depth_weights=cv::Mat::zeros(frame_depth.mat().rows,frame_depth.mat().cols,CV_32F);
	for(int row=0;row<frame_depth.mat().rows;row++)
	for(int col=0;col<frame_depth.mat().cols;col++)
	{
		float depth=frame_depth.mat().at<ushort>(row,col);
		if(depth>0)_cur_depth_weight.at<float>(row,col)=1;
	}
	_vec_depth_branch.push_back(new)


}
void SRKeyframeMan::updateRGBBranch(const ColorFrameData& frame_color,const Mat44& camera_pose)
{

}
void SRKeyframeMan::calNewSRFrame(const DepthFrameData& frame_depth,const ColorFrameData& frame_color,const Mat44& camera_pose)
{
	_cur_depth_weight=cv::Mat::zeros(frame_depth.mat().rows,frame_depth.mat().cols,CV_32F);
	_vec_color_weight=vector<cv::Mat>();
	KeyFrame newframe(frame_depth,frame_color,camera_pose);
	for(int row=0;row<frame_depth.mat().rows;row++)
	for(int col=0;col<frame_depth.mat().cols;col++)
	{
		float depth=frame_depth.mat().at<ushort>(row,col);
		if(depth>0)_cur_depth_weight.at<float>(row,col)=1;
	}


	_srframe_list.push_back(newframe);
}
void updateReprojected(cv::Mat& reprojected,float2 screenpos,float depth,cv::Mat &new_weight,const cv::Mat& target_mat)
{
	int rows=target_mat.rows;
	int cols=target_mat.cols;
	int2 screenpos_int=make_int2((int)(screenpos.x),(int)(screenpos.y));
	if(screenpos_int.x>=0&&screenpos_int.x<cols&&screenpos_int.y>=0&&screenpos_int.y<rows)
	{
		float last_depth=reprojected.at<ushort>(screenpos_int.y,screenpos_int.x)/1000.0;
		float target_depth=target_mat.at<ushort>(screenpos_int.y,screenpos_int.x)/1000.0;
		float dist2=(screenpos_int.x-screenpos.x)*(screenpos_int.x-screenpos.x)+
							(screenpos_int.y-screenpos.y)*(screenpos_int.y-screenpos.y);
		if(new_weight.at<float>(screenpos_int.y,screenpos_int.x)==0||abs(last_depth-target_depth)>abs(depth-target_depth))
		{
			new_weight.at<float>(screenpos_int.y,screenpos_int.x)=exp(-dist2);
			reprojected.at<ushort>(screenpos_int.y,screenpos_int.x)=depth*1000;
		}
	}
	if(screenpos_int.x+1>=0&&screenpos_int.x+1<cols&&screenpos_int.y>=0&&screenpos_int.y<rows)
	{
		float last_depth=reprojected.at<ushort>(screenpos_int.y,screenpos_int.x+1)/1000.0;
		float target_depth=target_mat.at<ushort>(screenpos_int.y,screenpos_int.x+1)/1000.0;
		if(new_weight.at<float>(screenpos_int.y,screenpos_int.x+1)==0||abs(last_depth-target_depth)>abs(depth-target_depth))
		{
			float dist2=(screenpos_int.x+1-screenpos.x)*(screenpos_int.x+1-screenpos.x)+
					(screenpos_int.y-screenpos.y)*(screenpos_int.y-screenpos.y);
			new_weight.at<float>(screenpos_int.y,screenpos_int.x+1)=exp(-dist2);
			reprojected.at<ushort>(screenpos_int.y,screenpos_int.x+1)=depth*1000;
		}
	}
	if(screenpos_int.x>=0&&screenpos_int.x<cols&&screenpos_int.y+1>=0&&screenpos_int.y+1<rows)
	{
		float dist2=(screenpos_int.x-screenpos.x)*(screenpos_int.x-screenpos.x)+
						(screenpos_int.y+1-screenpos.y)*(screenpos_int.y+1-screenpos.y);
		float last_depth=reprojected.at<ushort>(screenpos_int.y+1,screenpos_int.x)/1000.0;
		float target_depth=target_mat.at<ushort>(screenpos_int.y+1,screenpos_int.x)/1000.0;
		if(new_weight.at<float>(screenpos_int.y+1,screenpos_int.x)==0||abs(last_depth-target_depth)>abs(depth-target_depth))
		{
			new_weight.at<float>(screenpos_int.y+1,screenpos_int.x)=exp(-dist2);
			reprojected.at<ushort>(screenpos_int.y+1,screenpos_int.x)=depth*1000;
		}
	}
	if(screenpos_int.x+1>=0&&screenpos_int.x+1<cols&&screenpos_int.y+1>=0&&screenpos_int.y+1<rows)
	{
		float dist2=(screenpos_int.x+1-screenpos.x)*(screenpos_int.x+1-screenpos.x)+
						(screenpos_int.y+1-screenpos.y)*(screenpos_int.y+1-screenpos.y);
		float last_depth=reprojected.at<ushort>(screenpos_int.y+1,screenpos_int.x+1)/1000.0;
		float target_depth=target_mat.at<ushort>(screenpos_int.y+1,screenpos_int.x+1)/1000.0;
		if(new_weight.at<float>(screenpos_int.y+1,screenpos_int.x+1)==0||abs(last_depth-target_depth)>abs(depth-target_depth))
		{
			new_weight.at<float>(screenpos_int.y+1,screenpos_int.x+1)=exp(-dist2);
			reprojected.at<ushort>(screenpos_int.y+1,screenpos_int.x+1)=depth*1000;
		}
	}
}
void SRKeyframeMan::fusionToSRFrame(const DepthFrameData& frame_depth,
											const Mat44& origin_pose,
											const CameraParams& depth_camera_params)
{
	cv::Mat reprojected=frame_depth.mat().clone();
	cv::Mat new_weight=cv::Mat::zeros(frame_depth.mat().rows,frame_depth.mat().cols,CV_32F);
	int rows=frame_depth.mat().rows;
	int cols=frame_depth.mat().cols;
	for(int row=0;row<rows;row++)
	for(int col=0;col<cols;col++)
	{
		float depth=frame_depth.mat().at<ushort>(row,col)/1000.0;
		if(depth==0)continue;
		float3 v=DepthCamera::depthToSkeleton(col,row,depth,depth_camera_params);
		float4 reprojected_v=_srframe_list.back().camera_pose.getInverse()*origin_pose*make_float4(v.x,v.y,v.z,1);
		float2 screenpos=DepthCamera::projectSkeletonToScreenfloat(make_float3(reprojected_v.x,reprojected_v.y,reprojected_v.z),depth_camera_params);

		updateReprojected(reprojected,screenpos,reprojected_v.z,new_weight,_srframe_list.back().frame_depth.mat());
	}
	for(int row=0;row<rows;row++)
	for(int col=0;col<cols;col++)
	{
		float new_weight_cur=new_weight.at<float>(row,col);
		ushort new_depth_cur=reprojected.at<ushort>(row,col);
		float old_weight_cur=_cur_depth_weight.at<float>(row,col);
		ushort old_depth_cur=_srframe_list.back().frame_depth.mat().at<ushort>(row,col);
		float new_depth_mile=new_depth_cur/1000.0;
		float old_depth_mile=old_depth_cur/1000.0;
		if(new_depth_mile>0&&old_depth_mile>0&&abs(new_depth_mile-old_depth_mile)>0.01)
		{
			cout<<new_depth_mile<<" "<<old_depth_mile<<endl;
			continue;
		}
		_srframe_list.back().frame_depth.mat().at<ushort>(row,col)=
		(old_depth_cur*old_weight_cur+new_depth_cur*new_weight_cur)/(new_weight_cur+old_weight_cur);
		_cur_depth_weight.at<float>(row,col)=new_weight_cur+old_weight_cur;
	}
}
